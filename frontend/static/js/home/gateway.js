class GatewayGrain{constructor(){this.canvases=document.querySelectorAll('.gw-grain');if(!this.canvases.length)return;this.drawn=false;this.animating=false;this.designing=false;this.designDone=false;this._gen=0;this.canvasData=new Map();this.designDelay=1.0;this.designDuration=4.0;this.designStart=null;this.allPaths=[];this.totalW=0;this.totalH=0;this.lowPower=document.documentElement.classList.contains('low-power');this.observer=new ResizeObserver(()=>{if(this.drawn)return;this.drawAll();});this.canvases.forEach(c=>this.observer.observe(c.parentElement));requestAnimationFrame(()=>this.drawAll());}
drawAll(){const grid=document.querySelector('.gw-right');if(!grid)return;const gridRect=grid.getBoundingClientRect();if(gridRect.width===0||gridRect.height===0)return;this.totalW=gridRect.width;this.totalH=gridRect.height;const squares=[...document.querySelectorAll('.gw-img')].map(el=>{const r=el.getBoundingClientRect();return{left:r.left-gridRect.left,top:r.top-gridRect.top,right:r.right-gridRect.left,bottom:r.bottom-gridRect.top,width:r.width,height:r.height};});this.squares=squares;const rng=this.seededRng(42);this.allPaths=[];this.generateUnifiedPCB(this.totalW,this.totalH,rng,this.allPaths,squares);this.allPathCache=this.allPaths.map(path=>{const segLens=[];let totalLen=0;for(let i=1;i<path.length;i++){const dx=path[i].x-path[i-1].x;const dy=path[i].y-path[i-1].y;const len=Math.sqrt(dx*dx+dy*dy);segLens.push(len);totalLen+=len;}
return{segLens,totalLen};});const pathRng=this.seededRng(99);this.pathTimings=this.allPaths.map((_,i)=>{const base=i/this.allPaths.length;return Math.max(0,Math.min(0.7,base*0.55+pathRng()*0.15));});this.canvases.forEach(canvas=>{const parent=canvas.parentElement;const w=parent.offsetWidth;const h=parent.offsetHeight;if(w===0||h===0)return;canvas.width=w;canvas.height=h;canvas.style.width=w+'px';canvas.style.height=h+'px';const parentRect=parent.getBoundingClientRect();const offsetX=parentRect.left-gridRect.left;const offsetY=parentRect.top-gridRect.top;const ctx=canvas.getContext('2d',{willReadFrequently:true});this.drawDarkBase(ctx,w,h,offsetX,offsetY);const localPaths=this.filterPathsForRegion(this.allPaths,offsetX,offsetY,w,h);const mappedPaths=localPaths.map(p=>p.map(pt=>({x:pt.x-offsetX,y:pt.y-offsetY})));const baseFrame=ctx.getImageData(0,0,w,h);const pathCache=mappedPaths.map(path=>{const segLens=[];let totalLen=0;for(let i=1;i<path.length;i++){const dx=path[i].x-path[i-1].x;const dy=path[i].y-path[i-1].y;const len=Math.sqrt(dx*dx+dy*dy);segLens.push(len);totalLen+=len;}
return{segLens,totalLen};});this.canvasData.set(canvas,{ctx,w,h,offsetX,offsetY,paths:mappedPaths,pathCache,staticFrame:null,baseFrame});});this.drawn=true;this.designStart=performance.now()+this.designDelay*1000;this.designing=true;this.designDone=false;this.animateDesign();}
drawDarkBase(ctx,w,h,offsetX,offsetY){ctx.fillStyle='#080810';ctx.fillRect(0,0,w,h);const cx=this.totalW*0.5-offsetX;const cy=this.totalH*0.5-offsetY;const bgGrad=ctx.createRadialGradient(cx,cy,0,cx,cy,Math.max(this.totalW,this.totalH)*0.7);bgGrad.addColorStop(0,'rgba(15,15,30,0.4)');bgGrad.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=bgGrad;ctx.fillRect(0,0,w,h);const imageData=ctx.getImageData(0,0,w,h);const data=imageData.data;const grainRng=this.seededRng(offsetX*7+offsetY*13);for(let i=0;i<data.length;i+=4){const noise=(grainRng()-0.5)*8;data[i]=Math.max(0,Math.min(255,data[i]+noise));data[i+1]=Math.max(0,Math.min(255,data[i+1]+noise));data[i+2]=Math.max(0,Math.min(255,data[i+2]+noise));}
ctx.putImageData(imageData,0,0);}
animateDesign(){const gen=this._gen;const loop=(now)=>{if(gen!==this._gen||!this.designing)return;const elapsed=(now-this.designStart)/1000;if(elapsed<0){requestAnimationFrame(loop);return;}
const progress=Math.min(elapsed/this.designDuration,1);for(const[canvas,data]of this.canvasData){const{ctx,w,h,offsetX,offsetY,baseFrame}=data;ctx.putImageData(baseFrame,0,0);ctx.save();ctx.translate(-offsetX,-offsetY);ctx.lineCap='round';ctx.lineJoin='round';for(let pi=0;pi<this.allPaths.length;pi++){const path=this.allPaths[pi];const pathStart=this.pathTimings[pi];const pathDraw=0.3;const pathProgress=Math.max(0,Math.min(1,(progress-pathStart)/pathDraw));if(pathProgress<=0)continue;const cached=this.allPathCache[pi];const totalLen=cached.totalLen;const segLens=cached.segLens;const drawLen=pathProgress*totalLen;ctx.beginPath();ctx.moveTo(path[0].x,path[0].y);let accum=0;for(let i=0;i<segLens.length;i++){if(accum+segLens[i]<=drawLen){ctx.lineTo(path[i+1].x,path[i+1].y);accum+=segLens[i];}else{const remain=drawLen-accum;const t=remain/segLens[i];const dx=path[i+1].x-path[i].x;const dy=path[i+1].y-path[i].y;ctx.lineTo(path[i].x+dx*t,path[i].y+dy*t);break;}}
ctx.strokeStyle=`rgba(255,255,255,${0.05 * pathProgress})`;ctx.lineWidth=6;ctx.stroke();ctx.strokeStyle=`rgba(255,255,255,${0.3 * pathProgress})`;ctx.lineWidth=1.5;ctx.stroke();if(pathProgress<1&&pathProgress>0){let hx=path[0].x,hy=path[0].y,ha=0;for(let i=0;i<segLens.length;i++){if(ha+segLens[i]>=drawLen){const tt=(drawLen-ha)/segLens[i];hx=path[i].x+(path[i+1].x-path[i].x)*tt;hy=path[i].y+(path[i+1].y-path[i].y)*tt;break;}
ha+=segLens[i];hx=path[i+1].x;hy=path[i+1].y;}
const headGrad=ctx.createRadialGradient(hx,hy,0,hx,hy,8);headGrad.addColorStop(0,'rgba(255,255,255,0.6)');headGrad.addColorStop(0.4,'rgba(255,255,255,0.15)');headGrad.addColorStop(1,'rgba(255,255,255,0)');ctx.fillStyle=headGrad;ctx.fillRect(hx-8,hy-8,16,16);}}
const nodeMap=new Map();for(let pi=0;pi<this.allPaths.length;pi++){const pathStart=this.pathTimings[pi];const pathProgress=Math.max(0,Math.min(1,(progress-pathStart)/0.3));if(pathProgress<1)continue;const path=this.allPaths[pi];for(const pt of path){const key=`${Math.round(pt.x)},${Math.round(pt.y)}`;nodeMap.set(key,{x:pt.x,y:pt.y,count:(nodeMap.get(key)?.count||0)+1});}}
for(const[,node]of nodeMap){const bright=node.count>=2;const r=bright?3:2;if(bright){const grad=ctx.createRadialGradient(node.x,node.y,0,node.x,node.y,r*10);grad.addColorStop(0,'rgba(255,255,255,0.25)');grad.addColorStop(0.3,'rgba(255,255,255,0.08)');grad.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=grad;ctx.fillRect(node.x-r*10,node.y-r*10,r*20,r*20);}
ctx.fillStyle=bright?'rgba(255,255,255,0.85)':'rgba(255,255,255,0.4)';ctx.beginPath();ctx.arc(node.x,node.y,r,0,Math.PI*2);ctx.fill();}
ctx.restore();}
if(progress>=1){this.designing=false;this.designDone=true;if(this.onDesignDone){this.onDesignDone();}
for(const[canvas,data]of this.canvasData){const{ctx,w,h,offsetX,offsetY}=data;this.drawPCBRegion(ctx,w,h,offsetX,offsetY,this.totalW,this.totalH,this.allPaths);data.staticFrame=ctx.getImageData(0,0,w,h);}
this.animate();return;}
requestAnimationFrame(loop);};requestAnimationFrame(loop);}
generateUnifiedPCB(w,h,rng,paths,squares){const gridStep=Math.floor(Math.min(w,h)*0.055);const yMarginPct=0.16;const xMarginPx=gridStep*2;const zones=(squares||[]).map(sq=>({...sq,safeTop:sq.top+sq.height*yMarginPct,safeBottom:sq.bottom-sq.height*yMarginPct,safeLeft:sq.left+xMarginPx,safeRight:sq.right-xMarginPx}));const clampY=(y)=>{for(const z of zones){if(y>=z.top&&y<=z.bottom){return Math.max(z.safeTop,Math.min(z.safeBottom,y));}}
return y;};const safeSnapY=(rawY)=>{const snapped=Math.round(rawY/gridStep)*gridStep;return clampY(snapped);};const trunkCount=4+Math.floor(rng()*3);const trunks=[];const cols=Math.floor(w/gridStep);for(let t=0;t<trunkCount;t++){const col=2+Math.floor((cols-4)*(t/(trunkCount-1))+(rng()-0.5)*2);const x=col*gridStep;const yStart=Math.floor(rng()*h*0.08);const yEnd=h-Math.floor(rng()*h*0.08);trunks.push({x,yStart,yEnd});paths.push([{x,y:yStart},{x,y:yEnd}]);}
for(let i=0;i<trunks.length-1;i++){const a=trunks[i];const b=trunks[i+1];const connCount=2+Math.floor(rng()*3);for(let c=0;c<connCount;c++){const rawY=gridStep*(3+Math.floor(rng()*(Math.floor(h/gridStep)-5)));const y=clampY(rawY);paths.push([{x:a.x,y},{x:b.x,y}]);}}
for(const trunk of trunks){const branchCount=4+Math.floor(rng()*4);for(let b=0;b<branchCount;b++){const rawY=trunk.yStart+rng()*(trunk.yEnd-trunk.yStart);const y=safeSnapY(rawY);const dir=rng()<0.5?-1:1;const hLen=gridStep*(2+Math.floor(rng()*4));const bx2=trunk.x+dir*hLen;const hasJog=rng()<0.55;const jogDir=rng()<0.5?-1:1;const jogLen=hasJog?gridStep*(1+Math.floor(rng()*3))*jogDir:0;const pathPts=[{x:trunk.x,y},{x:bx2,y}];if(hasJog){const jogY=clampY(y+jogLen);pathPts.push({x:bx2,y:jogY});}
paths.push(pathPts);if(rng()<0.35){const rawSby=y+(rng()<0.5?-1:1)*gridStep*(1+Math.floor(rng()*2));const sby=clampY(rawSby);const sbx=trunk.x+dir*hLen*(0.4+rng()*0.3);const sbLen=gridStep*(1+Math.floor(rng()*2));const sbDir=rng()<0.5?-1:1;paths.push([{x:sbx,y},{x:sbx,y:sby},{x:sbx+sbDir*sbLen,y:sby}]);}}}
const floatCount=3+Math.floor(rng()*3);for(let f=0;f<floatCount;f++){const fx=rng()*w;const rawFy=rng()*h;const fy=clampY(rawFy);const fLen=gridStep*(1+rng()*2);const isVert=rng()<0.5;if(isVert){paths.push([{x:fx,y:fy},{x:fx,y:fy+fLen}]);}else{paths.push([{x:fx,y:fy},{x:fx+fLen,y:fy}]);}}}
drawPCBRegion(ctx,w,h,offsetX,offsetY,totalW,totalH,paths){ctx.fillStyle='#080810';ctx.fillRect(0,0,w,h);const cx=totalW*0.5-offsetX;const cy=totalH*0.5-offsetY;const bgGrad=ctx.createRadialGradient(cx,cy,0,cx,cy,Math.max(totalW,totalH)*0.7);bgGrad.addColorStop(0,'rgba(15,15,30,0.4)');bgGrad.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=bgGrad;ctx.fillRect(0,0,w,h);const traceW=1.5;const glowW=6;ctx.save();ctx.translate(-offsetX,-offsetY);ctx.lineCap='round';ctx.lineJoin='round';for(const path of paths){ctx.strokeStyle='rgba(255,255,255,0.05)';ctx.lineWidth=glowW;ctx.beginPath();ctx.moveTo(path[0].x,path[0].y);for(let i=1;i<path.length;i++)ctx.lineTo(path[i].x,path[i].y);ctx.stroke();ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.lineWidth=traceW;ctx.beginPath();ctx.moveTo(path[0].x,path[0].y);for(let i=1;i<path.length;i++)ctx.lineTo(path[i].x,path[i].y);ctx.stroke();}
const nodeMap=new Map();for(const path of paths){for(const pt of path){const key=`${Math.round(pt.x)},${Math.round(pt.y)}`;nodeMap.set(key,{x:pt.x,y:pt.y,count:(nodeMap.get(key)?.count||0)+1});}}
for(const[,node]of nodeMap){const bright=node.count>=2;const r=bright?3:2;if(bright){const grad=ctx.createRadialGradient(node.x,node.y,0,node.x,node.y,r*10);grad.addColorStop(0,'rgba(255,255,255,0.25)');grad.addColorStop(0.3,'rgba(255,255,255,0.08)');grad.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=grad;ctx.fillRect(node.x-r*10,node.y-r*10,r*20,r*20);}
ctx.fillStyle=bright?'rgba(255,255,255,0.85)':'rgba(255,255,255,0.4)';ctx.beginPath();ctx.arc(node.x,node.y,r,0,Math.PI*2);ctx.fill();}
ctx.restore();const imageData=ctx.getImageData(0,0,w,h);const data=imageData.data;const grainRng=this.seededRng(offsetX*7+offsetY*13);for(let i=0;i<data.length;i+=4){const noise=(grainRng()-0.5)*8;data[i]=Math.max(0,Math.min(255,data[i]+noise));data[i+1]=Math.max(0,Math.min(255,data[i+1]+noise));data[i+2]=Math.max(0,Math.min(255,data[i+2]+noise));}
ctx.putImageData(imageData,0,0);}
filterPathsForRegion(paths,ox,oy,w,h){const margin=30;return paths.filter(path=>path.some(pt=>pt.x>=ox-margin&&pt.x<=ox+w+margin&&pt.y>=oy-margin&&pt.y<=oy+h+margin));}
initGlobalPulses(){const paths=this.allPaths;if(paths.length===0)return[];const rng=this.seededRng(42*97);const count=Math.min(6,paths.length);const pulses=[];const used=new Set();for(let i=0;i<count;i++){let idx,tries=0;do{idx=Math.floor(rng()*paths.length);tries++;}
while(used.has(idx)&&tries<30);used.add(idx);pulses.push({pathIdx:idx,progress:-(rng()*0.5),speed:0.06+rng()*0.04,opacity:1,fading:false,cycles:0});}
return pulses;}
_usedPathIndices(){const used=new Set();for(const p of this.globalPulses)used.add(p.pathIdx);return used;}
animate(){const gen=this._gen;this.globalPulses=this.initGlobalPulses();let lastTime=performance.now();const startTime=lastTime;const pulseDuration=this.lowPower?8000:15000;const frameInterval=this.lowPower?66:33;let lastFrame=0;const loop=(now)=>{if(gen!==this._gen)return;if(now-startTime>pulseDuration){for(const[canvas,data]of this.canvasData){if(data.staticFrame)data.ctx.putImageData(data.staticFrame,0,0);}return;}
if(now-lastFrame<frameInterval){requestAnimationFrame(loop);return;}
lastFrame=now;const dt=(now-lastTime)/1000;lastTime=now;const paths=this.allPaths;for(const pulse of this.globalPulses){pulse.progress+=pulse.speed*dt;if(pulse.progress>=1&&!pulse.fading){pulse.fading=true;}
if(pulse.fading){pulse.opacity-=dt*0.5;if(pulse.opacity<=0){pulse.cycles++;if(pulse.cycles>=2){pulse.progress=2;pulse.opacity=0;continue;}
const used=this._usedPathIndices();const rng=this.seededRng(now*7+this.globalPulses.indexOf(pulse));let idx,tries=0;do{idx=Math.floor(rng()*paths.length);tries++;}
while(used.has(idx)&&tries<30);pulse.pathIdx=idx;pulse.progress=-0.1;pulse.opacity=1;pulse.fading=false;pulse.speed=0.06+rng()*0.04;}}}
const anyActive=this.globalPulses.some(p=>p.opacity>0&&p.progress<2);if(!anyActive){for(const[canvas,data]of this.canvasData){if(data.staticFrame)data.ctx.putImageData(data.staticFrame,0,0);}return;}
for(const[canvas,data]of this.canvasData){const{ctx,w,h,offsetX,offsetY,staticFrame}=data;if(!staticFrame)continue;ctx.putImageData(staticFrame,0,0);ctx.save();ctx.translate(-offsetX,-offsetY);for(const pulse of this.globalPulses){if(pulse.progress<0||pulse.opacity<=0||pulse.progress>=2)continue;const path=paths[pulse.pathIdx];if(!path||path.length<2)continue;this.drawPulse(ctx,path,Math.min(pulse.progress,1),pulse.opacity,this.allPathCache[pulse.pathIdx]);}
ctx.restore();}
requestAnimationFrame(loop);};requestAnimationFrame(loop);}
reset(){this._gen++;this.designing=false;this.designDone=false;const gw=document.getElementById('gateway');if(gw){gw.classList.remove('gw-sweep-active','gw-grid-ready');}
for(const[canvas,data]of this.canvasData){this.drawDarkBase(data.ctx,data.w,data.h,data.offsetX,data.offsetY);data.staticFrame=null;}
this.designStart=performance.now()+this.designDelay*1000;this.designing=true;this.animateDesign();}
drawPulse(ctx,path,progress,opacity,cached){const segLens=cached?cached.segLens:[];let totalLen=cached?cached.totalLen:0;if(!cached){for(let i=1;i<path.length;i++){const dx=path[i].x-path[i-1].x;const dy=path[i].y-path[i-1].y;const len=Math.sqrt(dx*dx+dy*dy);segLens.push(len);totalLen+=len;}}
if(totalLen===0)return;const targetDist=progress*totalLen;let accum=0,headX=path[0].x,headY=path[0].y;for(let i=0;i<segLens.length;i++){if(accum+segLens[i]>=targetDist){const t=(targetDist-accum)/segLens[i];headX=path[i].x+(path[i+1].x-path[i].x)*t;headY=path[i].y+(path[i+1].y-path[i].y)*t;break;}
accum+=segLens[i];headX=path[i+1].x;headY=path[i+1].y;}
const trailLen=totalLen*0.25;const trailStart=Math.max(0,targetDist-trailLen);const steps=this.lowPower?6:12;for(let s=0;s<steps;s++){const t=s/steps;const dist=trailStart+(targetDist-trailStart)*t;let px=path[0].x,py=path[0].y,a=0;for(let i=0;i<segLens.length;i++){if(a+segLens[i]>=dist){const tt=(dist-a)/segLens[i];px=path[i].x+(path[i+1].x-path[i].x)*tt;py=path[i].y+(path[i+1].y-path[i].y)*tt;break;}
a+=segLens[i];px=path[i+1].x;py=path[i+1].y;}
const brightness=t*t;const alpha=brightness*0.4*opacity;const r=4+brightness*8;const grad=ctx.createRadialGradient(px,py,0,px,py,r);grad.addColorStop(0,`rgba(255,255,255,${alpha})`);grad.addColorStop(0.4,`rgba(255,255,255,${alpha * 0.4})`);grad.addColorStop(1,'rgba(255,255,255,0)');ctx.fillStyle=grad;ctx.fillRect(px-r,py-r,r*2,r*2);}
const headAlpha=opacity;const outerR=20;const outerGrad=ctx.createRadialGradient(headX,headY,0,headX,headY,outerR);outerGrad.addColorStop(0,`rgba(255,255,255,${0.35 * headAlpha})`);outerGrad.addColorStop(0.3,`rgba(255,255,255,${0.12 * headAlpha})`);outerGrad.addColorStop(1,'rgba(255,255,255,0)');ctx.fillStyle=outerGrad;ctx.fillRect(headX-outerR,headY-outerR,outerR*2,outerR*2);const coreR=5;const coreGrad=ctx.createRadialGradient(headX,headY,0,headX,headY,coreR);coreGrad.addColorStop(0,`rgba(255,255,255,${0.95 * headAlpha})`);coreGrad.addColorStop(0.5,`rgba(255,255,255,${0.5 * headAlpha})`);coreGrad.addColorStop(1,'rgba(255,255,255,0)');ctx.fillStyle=coreGrad;ctx.fillRect(headX-coreR,headY-coreR,coreR*2,coreR*2);}
seededRng(seed){let s=Math.abs(Math.floor(seed))||1;return()=>{s=(s*16807+0)%2147483647;return(s-1)/2147483646;};}}
class GatewayTypewriter{constructor(onDone){this.el=document.querySelector('.gw-subtitle');if(!this.el){if(onDone)onDone();return;}
this.el.style.opacity='0';this.el.style.transform='translateY(0.5vw)';this.el.style.transition='opacity 0.8s ease, transform 0.8s ease';setTimeout(()=>{this.el.style.opacity='1';this.el.style.transform='translateY(0)';setTimeout(()=>{if(onDone)onDone();},800);},500);}
reset(onDone){if(!this.el){if(onDone)onDone();return;}
this.el.style.opacity='0';this.el.style.transform='translateY(0.5vw)';setTimeout(()=>{this.el.style.opacity='1';this.el.style.transform='translateY(0)';setTimeout(()=>{if(onDone)onDone();},800);},500);}}
function initGateway(){let designDone=false;let typeDone=false;const checkReady=()=>{if(designDone&&typeDone){const gw=document.getElementById('gateway');if(gw)gw.classList.add('gw-grid-ready');}};const grain=new GatewayGrain();grain.onDesignDone=()=>{designDone=true;const gw=document.getElementById('gateway');if(gw)gw.classList.add('gw-sweep-active');checkReady();};const tw=new GatewayTypewriter(()=>{typeDone=true;checkReady();});window.gatewayGrain=grain;window.resetGateway=()=>{designDone=false;typeDone=false;grain.reset();tw.reset(()=>{typeDone=true;checkReady();});};}
document.addEventListener('start-gateway',()=>initGateway());document.addEventListener('cinematic-done',()=>{if(!window.gatewayGrain)initGateway();});
